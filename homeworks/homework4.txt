Зад.1. (6т.) Разглеждаме правоъгълници в двумерното пространство със страни, успоредни на координатните оси. Можем да дефинираме този вид правоъгълници чрез координатите на техния долен ляв ъгъл (x1,y1) и горен десен ъгъл (x2,y2) и да го представяме в Haskell по следния начин:
  type Rect = (Int,Int,Int,Int)
където четирите числа са съответно (x1,y1,x2,y2). Да се напише функция mostPopular, която по даден непразен списък от правоъгълници връща този правоъгълник от списъка, който се пресича с най-много други правоъгълници. Ако има повече от един такъв правоъгълник, нека се връща някой от тях, за който лицето е максимално (той може също да не е единствен, но в този случай изборът няма значение).
Пример: mostPopular [(4,3,11,8),(7,0,13,6),(2,2,8,5),(0,4,6,7)] -> (4,3,11,8)

Зад.2. (7т.) Напишете функция check, която по даден списък от едноместни целочислени функции от тип (Int -> Int) и списък от числа връща дължината на най-дългата верига от функции (без повторения), чиято композиция съвпада с някоя друга функция от списъка върху всички дадени числа.
Пример: check [ (+1), (^2), (*3), (/2), \x -> 3*x^2 + 1 ] [1..100] -> 3 -- това са функциите (+1), (*3) и (^2)
Зад.3. (6т.) Нека е дадена матрица от числа. Седло в матрицата ще наричаме всяко число, което е или минимално в своя ред и същевременно максимално в своята колона, или максимално в реда си и минимално в колоната си. Напишете функция hasSaddle, която проверява дали съществува седло в дадена матрица от числа.

Бонус (3т.): напишете функция allSaddles, която връща списък от наредени двойки, даващи “координатите” (ред,стълб) на всички седла в матрицата.
Зад.4. (5т.) Генерирайте безкрайния списък от числа reprs = [ x0, x1, x2, … ], за който xi означава броя на начините, по които може да се представи i като сбор на две прости числа.
Зад.5. (8т.) Нека за целите на тази задача ще дефинираме “азбуката” като множеството от малките латински букви [‘a’..’z’]. Ще представяме крайните детерминирани автомати като наредена тройка от брой състояния, множество от крайни състояния и тотална* функция на преходите. За улеснение, ако броят на състоянията е n, то състоянията ще са номерирани с числата от 0 до n-1, а началното състояние винаги ще е с номер 0. Всеки преход ще бъде надписан с един символ от азбуката. Представянето на тези автомати в Haskell ще изглежда така:
  data DFA = DFA Int [Int] (Int -> Char -> Int)
Ще приемаме, че съществува невалидно (и не-крайно) състояние с индекс -1 такова, че достигне ли се до него, автоматът спира. Напишете функция match, която по даден DFA и стринг изчислява дали автоматът успешно разпознава стринга.

Пример:
trans :: Int -> Char -> Int
trans 0 ‘а’ = 1
trans 0 ‘b’ = 0
trans 0 ‘c’ = 0
trans 1 ‘a’ = 0
trans 1 ‘b’ = 1
trans 1 ‘c’ = 1
trans _  _  = -1 -- невалидното състояние
                 -- с тази клауза гарантираме тоталност на функцията

dfa1 :: DFA
dfa1 = DFA 2 [0] trans -- 2 състояния (с номера 0 и 1), измежду които само 0 е крайно

>check dfa1 “abcbcab”
True
>check dfa1 “baba”
True
>check dfa1 “baobab”
False
>check dfa1 "aaaaa"
False

dfa2 :: DFA
dfa2 = DFA 5 [4] (const . min 4 . (+1)) -- кой език разпознава този автомат?

>check dfa2 “iei”
False
>check dfa2 “ieei”
True

* функцията на преходите е тотална т.с.т.к. е дефинирана за всички индекси и елементи на азбуката. Възможно е за някои от тях тя да връща -1, когато не съществува такъв преход в автомата.

Бонус: (5т.) Съставете аналогичен тип data NFA = ..., представящ краен недетерминиран автомат, и напишете аналогична функция match’ за този тип автомати. Упътване: тук функцията на преходите ще е от тип (Int -> Char -> [Int]).