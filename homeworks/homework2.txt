Зад.1. (8т.) Нека е дадена квадратна матрица от числа. Под “Гаусова елиминация” ще разбираме операцията, при която се избира първият ред отгоре надолу, в който първият елемент е ненулев, и към всеки друг ред на матрицата (без избрания) прибавяме избрания ред, умножен по коефициент така, че числата в първия стълб на тези редове да станат равни на нула:
(( 1 5 2)     ((1  5 2)
 ( 2 3 8)  ->  (0 -7 4)   ; получено от (ред1 * (-2)) + ред2
 (-2 0 4))     (0 10 8))  ; получено от (ред1 * 2) + ред3
Напишете функция (row-reduce m), която извършва тази операция. Можете да допуснете, че в първия стълб на матрицата има поне един ненулев елемент.
Зад.2. (8т.) Напишете функция (cross-out m), която по дадена матрица от числа m с размери M*N генерира всички M*N на брой матрици, които могат да се получат от m със задраскване на някой ред и някой стълб. Редът на върнатите матрици няма значение.
Пример:
(cross-out '((1 2 3 4)      '(((6 7 8)  ((5 7 8)  ((5 6 8)  ((5 6 7)  ((2 3 4)
             (5 6 7 8)   ->    (0 1 2))  (9 1 2))  (9 0 2))  (9 0 1))  (0 1 2)) ...
             (9 0 1 2)))       ; и още 7 малки матрици
Зад.3. Нека е дадено символното представяне на едноместна числена функция f, например:
(define f ‘(* x x)), или
(define f ‘(/ (expt x 5) (+ (* 2 x) 1)))
Забележете, че това представяне е всъщност валидно тяло на функция в Scheme, само че цитирано с quote — резултатът е обикновен списък, съдържащ като подизрази символи за операции и променливи, числа, или вложени аналогични списъци. Обърнете внимание, че тези списъци съдържат само символи и числа, а не функции и числа. Важат и следните условия:
- f ще е функция само на една променлива, изразена чрез символа x
- в f могат да участват и константи
- f може да включва само следните математически операции: +, -, *, / и expt. Всички те ще приемат точно два аргумента, като вторият аргумент на expt винаги ще бъде число.
- f представлява валидно тяло на валидна числена функция (няма нужда да проверявате за това)

- (6т.) напишете функция (expr->tree e), която по символното представяне e на функция връща дървото на израза, който я представя.
- (5т.) напишете функция (tree-eval t x), която намира стойността на функцията в точка x по нейното дърво на оценяване t и дадена стойност на променливата x. Ще считаме, че x е от дефиниционното множество на функцията, т.е. няма нужда да се прави проверка за коректност.
- (6т.) напишете функция (tree-derive t), която намира производната на дадена функция по нейното дърво на оценяване. Тази функция също трябва да връща валидно дърво на оценяване, отговарящо точно на производната на първоначалната функция.

Примери:
(define f ‘(* x x))
(define t (expr->tree f))
(tree-eval t 5) -> 25
(define t1 (tree-derive t))
(tree-eval t1 5) -> 10
; Производната на x2 е 2x, следователно t1 трябва да е еквивалентно на (expr->tree (* 2 x)) и при оценяване да връща точната стойност 10, а не 10.000000010497 или нещо подобно.

Бонуси:
- (3т.) допълнете своите функции expr->tree, tree-eval и tree-derive така, че да работят с едноместни функции като sqrt, log и exp. Упътване: едноместните функции са точно като двуместните, само че не зависят от втория си аргумент.
- (4т.) допълнете своите функции expr->tree, tree-eval и tree-derive така, че да могат да приемат и повече от два аргумента за операциите + и *.
- (5т.) допълнете своите функции expr->tree, tree-eval и tree-derive така, че да няма ограничение върху вида на аргументите на expt, т.е. може и двата аргумента да са изрази, съдържащи x.